Optimize while tracking

AYE:  1.4087111875698657 APE:  1.813354103226718 ARE:  1.161435717448039
RYE:  1.1424224127174025 RPE:  1.2755228027392318 RRE:  1.114504263178676
0.053895

0.06659555795040355

//
// Created by lupta on 1/26/2022.
//

#ifndef BUNDLE_ADJUSTMENT_OPTIMIZATIONCONFIG_H
#define BUNDLE_ADJUSTMENT_OPTIMIZATIONCONFIG_H

#include "OptimizationUtils.h"
#include <string>
#include "Eigen/Dense"
#include <fstream>
#include <utility>
#include <ceres/ceres.h>
#include "sophus/local_parameterization_se3.hpp"
#include <iostream>
#include <string>

using namespace std;
using namespace Eigen;


class BundleAdjustmentConfig {

public:
    /*
     *  File paths
     */
    const string CAMERA_DEFAULT_INTRINSICS_PATH = "../../Data/ros_default_intrinsics.txt";
    const string DATASET_FILEPATH = "../../Data/rgbd_dataset_freiburg1_xyz/"; // SET TO <your_path>/rgbd_dataset_freiburg1_xyz/
    const string GROUND_TRUTH_PATH = "../../Data/rgbd_dataset_freiburg1_xyz/groundtruth.txt";
    const string OUTPUT_POSES_PATH = "../../output/freiburg1_xyz_poses.txt"; // output:

    /*
     *  Keypoint extraction + feature matching
     */
    const string DETECTOR = "ORB"; // options: ORB, SIFT, SURF
    int NUM_FEATURES = 1000; // hyperparameter for ORB and SIFT
    int HESSIAN_THRES = 8000; // hyperparameter for SURF; default value: 100
    const uint KEYFRAME_INCREMENT = 5;
    const float LOWE_THRESHOLD = .7;

};

class ceresGlobalProblem {
public:

    const double HUB_P_REPR = 1e-3; // Huber loss parameter for reprojection constraints
    const double WEIGHT_INTRINSICS = 1e-6;
    const double WEIGHT_UNPR = 2; // weight for unprojection constraint. Relative to the reprojection constraints, who have a weight of 1
    const double HUB_P_UNPR = 1e-3; // Huber loss parameter for depth prior (i.e. unprojection constraints)

    const int frame_frequency = 10;  // wait this many frames to do optimization again
    const int window_size = 30; // how many keyframes are we optimizing for every window? Put -1 to have a unique window, put 0 to skip optimization

    ceres::Solver::Options options;

    ceresGlobalProblem() {
        initialize_options();
    }

    void initialize_options() {
        options.linear_solver_type = ceres::SPARSE_NORMAL_CHOLESKY;
        options.minimizer_progress_to_stdout = true;
        options.max_num_iterations = 75;
        options.eta = 1e-6;
        options.trust_region_strategy_type = ceres::DOGLEG;
    }

};

#endif //BUNDLE_ADJUSTMENT_OPTIMIZATIONCONFIG_H


int main() {

    // Some configurations
    auto cfg = BundleAdjustmentConfig();
    auto cfg_optimization = ceresGlobalProblem();

    /////////////////////////////
    //  WINDOWED OPTIMIZATION  //
    /////////////////////////////

    // The things we're interested in
    Map3D map;
    vector<KeyFrame> keyframes;
    Vector4d intrinsics_initial = read_camera_intrinsics_from_file(cfg.CAMERA_DEFAULT_INTRINSICS_PATH);
    auto intrinsics_optimized(intrinsics_initial);  // to be later optimized

    // Uncomment this and comment from that onwards, for debugging
//    optimizeDebug(cfg_optimization, intrinsics_initial, intrinsics_optimized, 0);

    // Temporary variables
    LandmarkId landmark_id = 0;

    // Load the sequence
    cout << "Initialize virtual sensor..." << endl;
    VirtualSensor sensor(cfg.KEYFRAME_INCREMENT);
    if (!sensor.Init(cfg.DATASET_FILEPATH)) {
        cout << "Failed to initialize the sensor.\nCheck file path." << endl;
        return -1;
    }

    // Process every frame in the sequence, optimize once in a while
    bool do_windowed_optimization = (cfg_optimization.window_size > 0), do_global_optimization = (
            cfg_optimization.window_size < 0);
    while (sensor.ProcessNextFrame()) {
        tracking_step(sensor, keyframes, map, cfg, landmark_id, intrinsics_initial);    // Tracking step
        if (do_windowed_optimization && keyframes.size() % cfg_optimization.frame_frequency == 0 &&
            keyframes.size() >= cfg_optimization.window_size) {
            windowOptimize(cfg_optimization, keyframes.size() - cfg_optimization.window_size, keyframes.size() - 1,
                           keyframes, map, intrinsics_initial, intrinsics_optimized);
        }   // Optimization step
    }
    if (do_windowed_optimization && keyframes.size() % cfg_optimization.frame_frequency != 0) {
        windowOptimize(cfg_optimization,
                       keyframes.size() - cfg_optimization.window_size,
                       keyframes.size() - 1, keyframes, map, intrinsics_initial, intrinsics_optimized);
    }   // Leftovers

    // Run instead global optimization
    if (do_global_optimization) {
        windowOptimize(cfg_optimization, 0, keyframes.size() - 1, keyframes, map, intrinsics_initial,
                       intrinsics_optimized);
    }

    cout << endl << "End of optimization. Writing output to file..." << endl;

    // Adjust the output so that the first pose aligns with ground_truth.txt, and is not just identity
    // (for ATE evaluation, and trajectory plotting).
    auto firstPose = getFirstPose(keyframes[0].timestamp, cfg.GROUND_TRUTH_PATH);
    poseOffset(keyframes, firstPose);

    // Write output to file
    write_keyframe_poses_to_file(cfg.OUTPUT_POSES_PATH, keyframes);


    return 0;
}
